# <ins>Project 1: Simple Shell</ins>

Project Description:
The goal of this project is to implement a basic shell which is able to execute commands, redirect the standard input/output (​stdin/stdout​) of commands to files, pipe the output of commands to other commands, and carry out commands in the background. In the optional previous assignment, you developed a shell parser that implements the same input requirements as this assignment. If you started or completed challenge 0, be sure to use that as your starting point for this assignment!
Your shell must implement a simple REPL (read – eval – print – loop) paradigm. Your shell must use “​my_shell$​” (without the quotes) as prompt. At each prompt, the user must be able to type commands (e.g., ​ls​, ​ps​, ​cat​) which shall be executed by the shell. You can access these binaries by searching directories determined by the PATH environment variable that is passed to your shell (HINT: read the man pages for the various execv wrappers. One of them performs the search for you).
Commands can have arguments that are separated by whitespace (one or more space characters). For example, if the user types ​cat x​, your shell will need to invoke the cat​ binary and pass ​x​ as an argument. When the shell has received a line of input, it typically waits until all commands have finished. Only then, a new prompt is displayed (however, this behavior can be altered – see below for details).
Your shell must also be able to interpret and execute the following meta-characters: ‘<’, ‘>’, ‘|’, and ‘&’:

command​ < ​filename​: In this case, a command takes its input from the file (not stdin). Note that spacing is irrelevant around the < operator. For example, ​cat<file​ and ​cat <file​ are valid inputs. Also, only one input redirection is allowed for a single command. (​cat<<file ​is invalid)
command​ > ​filename​: An input following this template indicates that a command writes its output to the specified file (not stdout). Again, spacing is irrelevant (see case a) and only one input redirection is allowed for a single command.
command1 | command2: The pipe character allows several commands to be connected, forming a pipeline. The output of the command before “​|​” is piped to the input of the command following “​|​”. A series of multiple piped commands is allowed on the command line. Spacing is irrelevant (described above). Example: ​cat a| sort | wc​ indicates that the output of the ​cat​ command is channeled to the ​sort​ and ​sort​ sends its output to the input of the ​wc​ program.
command & The ampersand character '​&​’ should allow the user to execute a command (or pipeline of commands) in the background. In this case, the shell immediately displays a prompt for the next line regardless of whether the commands on the previous line have finished or are still in progress.